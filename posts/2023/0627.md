---
title: "TIL - 230627"
subtitle: "Today I Leared / Javascript 복습"
date: "2023-06-27"
tag: "JS"
---

- JS 역사
  - 1995, 브라우저에서 HTML을 동적으로 사용을 원함 > 프로그래밍 언어 개발(브렌던 아이크 씨) > 자바스크립트 개발
  - 여러가지 브라우저에서 각자 자바스크립트를 따로 씀 > 표준화 필요 > ECMA 인터내셔널(표준화기구) 요청
    - ECMAScript로 표준화 작업(줄여서 ES-)
    - ECMAScript6 (ES6, ECMAScript 2015)
      - let/const, 화살표 함수, 클래스, 모듈 등 도입 > 현대화
      - ECMAScript8 (ES8, ECMAScript 2017)
        - async/await 도입
  - 1999, 비동기적 통신 ajax 도입
    - 새로고침 없이, 전체 재렌더링 없이, 필요한 부분만 재렌더링
  - 2006, jquery 등장
    - DOM 접근 편리성 증대
  - 2008, 구글 V8 Javascript 엔진 출시
    - javascript 웹 어플리케이션 구축 요구 부합
    - 웹서버에서 수행하던 많은 부분이 브라우저 단으로 이동
    - 프론트엔드의 부각
  - 2009, Node.js 등장
    - javascript를 브라우저 이외의 환경에서 실행할 수 있는 환경 제공
    - javascript로 프론트엔드/백엔드 역할 모두 가능
    - like JVM
- Node.js, npm
  - Node.js
    - Chrome V8 Javascript Engine으로 빌드된 Javascript Runtime Environment
    - 브라우저 밖에서 Javasciprt 사용할 수 있게 해줌
    - 주로 서버 사이드 애플리케이션 개발에 사용
    - 모듈(각종 편리한 기능), 파일 시스템(내컴퓨터 문서읽기), HTTP(네트워크)에 필요한 빌트인API 제공
    - 데이터 실시간 처리하여 빈번한 I/O가 발생하는 Single Page Application에 적합
      - I/O : input/output 입출력
    - cpu 사용률이 높은 어플리케이션에는 부적합
      - 단일 스레드의 단점
  - npm(node package manager)
    - Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할
    - 패키지 관리를 위한 CLI 제공
    - yarn
      - 구 페이스북 현 메타에서 개발한 Node.js 모듈(패키지) 매니저
      - npm 보다 속도, 안정성, 보안성 높음
- [브라우저 동작 원리](https://poiemaweb.com/js-browser)
- 값
  - 리터럴
    - 숫자
    - 문자열
    - 불리언
    - null
    - undefined
    - 객체
    - 배열
    - 정규표현식
    - 함수
  
    ```
    // 숫자 리터럴
    10.50
    1001

    // 문자열 리터럴
    'Hello'
    "World"

    // 불리언 리터럴
    true
    false

    // null 리터럴
    null

    // undefined 리터럴
    undefined

    // 객체 리터럴
    { name: 'Lee', gender: 'male' }

    // 배열 리터럴
    [ 1, 2, 3 ]

    // 정규표현식 리터럴
    /ab+c/

    // 함수 리터럴
    function() {}
    ```
    
- 데이터타입
  
  ```
  // Number
  var num1 = 1001;
  var num2 = 10.50;

  // String
  var string1 = 'Hello';
  var string2 = "World";

  // Boolean
  var bool = true;

  // null
  var foo = null;

  // undefined
  var bar;

  // Object
  var obj = { name: 'Lee', gender: 'male' };

  // Array
  var array = [ 1, 2, 3 ];

  // function
  var foo = function() {};

  // 심볼 key는 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키
  var key = Symbol('key');
  console.log(typeof key); // symbol

  var obj = {};
  obj[key] = 'value';
  console.log(obj[key]); // value
  ```

- [연산자](https://poiemaweb.com/js-operator)
- 변수
  - 값의 저장, 참조에 사용
  - var
    - 함수 레벨 스코프
    - var 키워드 생략 허용(전역변수화)
    - 중복 선언 허용
    - 변수 호이스팅
      - 변수 선언하기 전 참조 가능
  - let
  - const
- 타입변환
  - 명시적 타입 변환(Exlicit coercion) 또는 타입 캐스팅(Type casting)
  
  ```
  var x = 10;

  // 명시적 타입 변환
  var str = x.toString(); // 숫자를 문자열로 타입 캐스팅한다.
  console.log(typeof str); // string
  ```

  - 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)

  ```
  var x = 10;

  // 암묵적 타입 변환
  // 숫자 타입 x의 값을 바탕으로 새로운 문자열 타입의 값을 생성해 표현식을 평가한다.
  var str = x + '';

  console.log(typeof str, str); // string 10

  // 변수 x의 값이 변경된 것은 아니다.
  console.log(x); // 10


  // 표현식이 모두 문자열 타입이여야 하는 컨텍스트
  '10' + 2               // '102'
  `1 * 10 = ${ 1 * 10 }` // "1 * 10 = 10"

  // 표현식이 모두 숫자 타입이여야 하는 컨텍스트
  5 * '10' // 50

  // 표현식이 불리언 타입이여야 하는 컨텍스트
  !0 // true
  if (1) { }

  // 이 외에도 여러가지 알아서 찾아보도록
  ```

- 객체
  - 원시타입을 제외한 모든 것은 객체
  - javascript 객체
    - key와 value로 구성된 프로퍼티(데이터)
    - 함수
  - 객체생성
    - 함수

    ```
    // 생성자 함수
    function Person(name, gender) {
    this.name = name;
    this.gender = gender;
    this.sayHello = function(){
        console.log('Hi! My name is ' + this.name);
    };
    }

    // 인스턴스의 생성
    var person1 = new Person('Lee', 'male');
    var person2 = new Person('Kim', 'female');

    console.log('person1: ', typeof person1);
    console.log('person2: ', typeof person2);
    console.log('person1: ', person1);
    console.log('person2: ', person2);

    person1.sayHello();
    person2.sayHello();
    ```

    ```
    function Person(name, gender) {
    var married = true;         // private
    this.name = name;           // public
    this.gender = gender;       // public
    this.sayHello = function(){ // public
        console.log('Hi! My name is ' + this.name);
    };
    }

    var person = new Person('Lee', 'male');

    console.log(typeof person); // object
    console.log(person); // Person { name: 'Lee', gender: 'male', sayHello: [Function] }

    console.log(person.gender);  // 'male'
    console.log(person.married); // undefined
    ```

    this는 생성자 함수가 생성할 인스턴스 가르킴

    - 프로퍼티 값 읽기

    ```
    var person = {
        name: 'kim',
        'age': 9
    }

    console.log(person.name) // 'kim'
    console.log(person.age) // 9
    console.log(person['age']) // 9

    console.log(person[age]) //  ReferenceError: gender is not defined
    ```

    - 프로퍼티 값 갱신

    ```
    var person = {
        name: 'kim'
    }

    person[name] = 'lee'    
    // 또는
    // person.name = 'lee'

    console.log(person.name) // 'lee'
    ```

    - 프로퍼티 값 동적 생성

    ```
    var person = {
        name: 'kim'
    }

    person.age = 9
    // 또는
    // person[age] = 9

    console.log(person.age) // 9
    ```

    - 프로퍼티 값 삭제

    ```
    var person = {
        name: 'kim'
        age: 9
    }

    delete person.age;
    console.log(person.age) // undefined

    delete person;
    console.log(person) // {name: 'kim'}
    ```

    - 반복문과 프로퍼티

    ```
    var person = {
        name: 'kim',
        age: 9,
        married: true
    }

    // for...in
    for(var prop in person) {
        console.log(prop + ' : ' + person[prop]);
    }

    // array for...of
    var people = ['kim', 'lee', 'park'];
    for(var index of people) {
        console.log(people[index]);
    }
    ```

  - pass-by-reference 와 pass-by-value
    - 객체는 pass-by-reference
      - 변경 가능(mutable)하기 때문
    - 원시타입은 pass-by-value
      - [변경불가성](https://poiemaweb.com/js-immutability)

- 함수
  - 함수 정의하기
    - 함수 선언문
    - 함수 표현식
    - Function 생성자 함수
  - <details>
    <summary>함수 선언문</summary>

    ```
        function square(number) {
            return number * number;
        }
    ```

    </details>
  - <details>
    <summary>함수 표현식</summary>

    ```
        // 익명 함수 표현식
        var square = function (number) {
            return number * number;
        }

        // 기명 함수 표현식(잘 안씀)
        var add = function addFnc(number) {
            return number + 1;
        }
    ```

    </details>
  - <details>
    <summary>Function 생성자 함수</summary>

    ```
    var square = new Function('number', 'return number * number');
    console.log(square(10)); // 100
    ```

    </details>
    
  - [함수 자세히 알아보기](https://poiemaweb.com/js-function)
- protoType
  - JS는 프로토타입 기반 객체지향 프로그래밍 언어
    - ES6에서 class 추가됨
    - 자바스크립트의 모든 객체는 자신의 부모와 연결되어 있음
  - java는 클래스 기반 객체지향 프로그래밍 언어
  - [protoType 자세히보기](https://poiemaweb.com/js-prototype)
- javascript 스코프(scope)
  - var는 함수 레벨 스코프

  ```
    var a = 10;     // 전역변수

    (function () {
    var b = 20;   // 지역변수
    })();

    console.log(a); // 10
    console.log(b); // "b" is not defined
  ```

  - 렉시컬 스코프

  ```
    var x = 1;

    function foo() {
    var x = 10;
    bar();
    }

    function bar() {
    console.log(x);
    }

    foo(); // ?
    bar(); // ?

    // 정답은
    // 1
    // 1

    // 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다
    // 반대는 정적 스코프
  ```

- [strict 모드](https://poiemaweb.com/js-strict-mode)
- [this](https://poiemaweb.com/js-this)
- [closure 클로저](https://poiemaweb.com/js-closure)
  - 함수가 선언됐을 때 렉시컬 환경

    ```
    function outerFunc() {
        var x = 10;
        var innerFunc = function () { console.log(x); };
        innerFunc();
    }

    outerFunc(); // 10
    ```

  - 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부름</br>
  ==> 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수

  - [js로 객체지향프로그래밍 하기](https://poiemaweb.com/js-object-oriented-programming)
  - 빌트인 객체
    - Native object
      - Object, String, Number, Function, Array, RegExp, Date, Math... 
    - Host object
      - [전역객체](https://poiemaweb.com/js-global-object) : window
        - BOM(Browser Object Model)
          - document
          - history
          - location
          - navigator
          - screen
        - DOM(Document Object Model)
          - < html >
            - < head >
            - < body >
              - ...
      - XMLHttpRequest, fetch (ajax)
      - HTML5 APIs : Blob, File, Canvas, Ceolocaion, Drag&Drop, Web storage ...
    - User-defined object
- [Event](https://poiemaweb.com/js-event)
  - this

  ```
    <!DOCTYPE html>
    <html>
    <body>
    <button onclick="foo()">Button</button>
    <script>
        // 인라인 이벤트 핸들러 방식의 경우,
        // 이벤트 핸들러는 일반 함수로서 호출되므로
        // 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다.

        function foo () {
            console.log(this); // window
        }
    </script>
    </body>
    </html>
  ```

  ```
  <!DOCTYPE html>
    <html>
    <body>
    <button class="btn">Button</button>
    <script>
        // 이벤트 핸들러는 메소드이므로
        // 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킨다

        const btn = document.querySelector('.btn');

        btn.onclick = function (e) {
            console.log(this); // <button id="btn">Button</button>
            console.log(e.currentTarget); // <button id="btn">Button</button>
            console.log(this === e.currentTarget); // true
        };
    </script>
    </body>
    </html>
  ```

- [비동기식 처리 모델과 ajax](https://poiemaweb.com/js-ajax)